package stu.GabrielParrott.labd;

/**
 * Factory class to generate VertexAccessPolygon objects for convenience.
 * 
 * @author Gabriel Parrott
 *
 */
public class PolygonFactory {
	/**
	 * Types of polygons that can be generated by this class.
	 * 
	 * @author Gabriel
	 *
	 */
	public static enum Type {
		Triangle, Square, Pentagon, Hexagon
	}

	/**
	 * Gets a VertexAccessPolygon object at the specified coordinates with the
	 * specified shape and size
	 * 
	 * @param x
	 *            The x coordinate of the center
	 * @param y
	 *            The y coordinate of the center
	 * @param side_length
	 *            The size of the polygon
	 * @param shape
	 *            The shape of the polygon
	 * @return A VertexAccessPolygon object from the specified parameters. A
	 *         triangle if the type parameter is invalid.
	 */
	public static VertexAccessPolygon getPolygonAt(int x, int y,
			int side_length, Type shape) {
		switch (shape) {
		case Triangle:
			return getTriangle(x, y, side_length);
		case Square:
			return getSquare(x, y, side_length);
		case Pentagon:
			return getPentagon(x, y, side_length);
		case Hexagon:
			return getHexagon(x, y, side_length);
		default:
			return getTriangle(x, y, side_length);
		}
	}

	/**
	 * Gets an equilateral triangle with a center (x,y) and side length equal to
	 * side_length
	 * 
	 * @param x
	 *            The x coordinate of the middle
	 * @param y
	 *            The y coordinate of the middle
	 * @param side_length
	 *            The length of the sides
	 * @return The equilateral triangle specified
	 */
	private static VertexAccessPolygon getTriangle(int x, int y, int side_length) {
		int[] xVerts = new int[3];
		int[] yVerts = new int[3];

		xVerts[0] = x - (int) (side_length / 2);
		xVerts[1] = x;
		xVerts[2] = x + (int) (side_length / 2);

		yVerts[0] = y + (int) (side_length / 2);
		yVerts[1] = y - (int) (side_length / 2);
		yVerts[2] = y + (int) (side_length / 2);

		return new VertexAccessPolygon(xVerts, yVerts, 3);
	}

	/**
	 * Gets a square with the specified center point and side length
	 * 
	 * @param x
	 *            The x coordinate of the center
	 * @param y
	 *            The y coordinate of the center
	 * @param side_length
	 *            The length of the sides
	 * @return The square specified
	 */
	private static VertexAccessPolygon getSquare(int x, int y, int side_length) {
		int[] xVerts = new int[4];
		int[] yVerts = new int[4];

		int half_side = (int) (side_length / 2);

		xVerts[0] = x - half_side;
		xVerts[1] = x + half_side;
		xVerts[2] = x + half_side;
		xVerts[3] = x - half_side;

		yVerts[0] = y - half_side;
		yVerts[1] = y - half_side;
		yVerts[2] = y + half_side;
		yVerts[3] = y + half_side;

		return new VertexAccessPolygon(xVerts, yVerts, 4);
	}

	/**
	 * Gets a pentagon at the specified center point with the given radius
	 * 
	 * @param x
	 *            The x coordinate of the center point
	 * @param y
	 *            The y coordinate of the center point
	 * @param radius
	 *            The radius of the pentagon
	 * @return The specified pentagon
	 */
	private static VertexAccessPolygon getPentagon(int x, int y, int radius) {
		int[] xVerts = new int[5];
		int[] yVerts = new int[5];

		int angle = 72;

		for (int i = 0; i < 5; ++i) {
			xVerts[i] = x
					- (int) (radius * Math.sin(Math.toRadians(i * angle)));
			yVerts[i] = y
					- (int) (radius * Math.cos(Math.toRadians(i * angle)));
		}

		return new VertexAccessPolygon(xVerts, yVerts, 5);
	}

	/**
	 * Gets a hexagon at the specified center point with the given radius
	 * 
	 * @param x
	 *            The x coordinate of the center point
	 * @param y
	 *            The y coordinate of the center point
	 * @param radius
	 *            The radius of the hexagon
	 * @return The specified hexagon
	 */
	private static VertexAccessPolygon getHexagon(int x, int y, int radius) {
		int[] xVerts = new int[6];
		int[] yVerts = new int[6];

		int angle = 60;

		for (int i = 0; i < 6; ++i) {
			xVerts[i] = x
					- (int) (radius * Math.cos(Math.toRadians(i * angle)));
			yVerts[i] = y
					- (int) (radius * Math.sin(Math.toRadians(i * angle)));
		}

		return new VertexAccessPolygon(xVerts, yVerts, 6);
	}
}
